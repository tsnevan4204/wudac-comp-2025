# app.py - FINAL STABLE VERSION (Random Colors & Placeholders)

from flask import Flask, render_template, request, redirect, url_for, session, flash
import pandas as pd
import joblib
import random
from collections import Counter, defaultdict
from itertools import combinations
import urllib.parse
import colorsys # For generating pleasant colors
import math # For brightness calculation

app = Flask(__name__)
app.secret_key = 'science1' # IMPORTANT: Change this for production!

CATEGORY_EMOJI_MAP = {
    "APPAREL": "👕", # T-shirt (could also use 👗, 👖)
    "APPLIANCE ACCESSORIES": "🔩", # Nut and Bolt (generic accessory) or 🔧
    "APPLIANCES": "🔌", # Electric Plug (could also use 🧊, 🔥, 🧺)
    "ARTS & CRAFTS": "🎨", # Artist Palette
    "AUTO & TIRES": "🚗", # Automobile (could also use  टायर)
    "BABY": "👶", # Baby
    "BAGS & ACCESSORIES": "👜", # Handbag (could also use 🎒, 💼)
    "BEAUTY": "💄", # Lipstick
    "BEDDING, BATH, & DECOR": "🖼️", # Framed Picture (generic decor, could use 🛏️, 🛁)
    "BOOKS": "📚", # Books
    "CAMERAS & CAMCORDERS": "📷", # Camera
    "COMPUTERS & PRINTERS": "💻", # Laptop (covers both well, could use 🖨️)
    "ELECTRONICS ACCESSORIES": "🎧", # Headphones (generic accessory, could use 🖱️, 🔌)
    "FLOWERS & GIFTS": "💐", # Bouquet (could also use 🎁)
    "FOOD & BEVERAGE": "🍎", # Red Apple (generic food, could use 🛒, ☕)
    "FURNITURE & STORAGE": "🛋️", # Couch and Lamp
    "HEALTH": "⚕️", # Medical Symbol (or ❤️‍🩹)
    "HOBBIES": "🪁", # Kite (generic hobby, could use 🎣, 🧵)
    "HOME IMPROVEMENT": "🛠️", # Hammer and Wrench
    "HOME THEATER": "🎬", # Clapper Board (or 📽️, 🔊)
    "HOUSEHOLD ESSENTIALS & CLEANING SUPPLIES": "🧽", # Sponge (or 🧹, 🧼)
    "JEWELRY": "💍", # Ring
    "KITCHEN & DINING": "🍽️", # Fork and Knife with Plate
    "LAWN CARE & EQUIPMENT": "🌱", # Seedling (or  mower emoji if available 🧑‍🌾)
    "MOBILE DEVICES": "📱", # Mobile Phone
    "MOVIES & TV": "📺", # Television
    "MUSIC": "🎵", # Musical Note (or 🎧, 🎸)
    "OFFICE & SCHOOL SUPPLIES": "📎", # Paperclip (or ✏️, ✂️)
    "OFFICE TECHNOLOGY": "📠", # Fax Machine (a bit retro, maybe 📞 or 💻)
    "OFFLINE SERVICES": "🤝", # Handshake (generic service)
    "OTHER ELECTRONICS": "💡", # Light Bulb (generic electronic)
    "PARTY & OCCASIONS": "🎉", # Party Popper
    "PATIO DECOR, FURNITURE, & COOKING": "🌳", # Deciduous Tree (generic outdoor, could use ♨️)
    "PETS": "🐾", # Paw Prints
    "PHONE & DATA PLANS": "📶", # Antenna Bars
    "PRINTS": "🖼️", # Framed Picture (similar to decor, maybe use 🏞️)
    "SHIPPING SERVICES & SUPPLIES": "📦", # Package
    "SHOES": "👟", # Running Shoe
    "SPORTS & OUTDOORS": "⚽", # Soccer Ball
    "TOYS": "🧸", # Teddy Bear
    "VIDEO GAME CONSOLES & ACCESSORIES": "🎮", # Video Game Controller
    "VIDEO GAMES (X CONSOLES)": "🕹️", # Joystick (differentiate from console)
    "WORKPLACE SUPPLIES": "🗄️", # File Cabinet (or 📊)
}
DEFAULT_EMOJI = "❓" # Fallback emoji

# --- Load Pre-trained Models and Data ---
# Attempt to load all necessary files generated by train_and_save.py
try:
    print("Loading pre-trained models and data...")
    svd_model = joblib.load('svd_model.joblib')
    cooc_matrix = joblib.load('cooccurrence_matrix.joblib')
    user_map = joblib.load('user_map.joblib') # raw_user_id -> inner_user_id
    item_map = joblib.load('item_map.joblib') # raw_item_id -> inner_item_id
    item_map_reverse = joblib.load('item_map_reverse.joblib') # inner_item_id -> raw_item_id
    df_user_lookup = joblib.load('user_lookup_data.joblib') # Contains machine_id, household_income, children
    product_list = joblib.load('product_list.joblib') # List of product category names
    category_to_products_map = joblib.load('category_to_products_map.joblib') # Map: category -> [prod_name]
    print("Models and data loaded successfully.")
    # Basic check if maps are loaded correctly
    if not user_map or not item_map or not product_list:
        print("Warning: User map, item map, or product list is empty after loading.")
        svd_model = None # Mark loading as failed if essential data is missing
except FileNotFoundError as e:
    print(f"Error loading files: {e}")
    print("FATAL: Ensure 'train_and_save.py' was run successfully first!")
    svd_model = None; cooc_matrix = {}; user_map = {}; item_map = {}; item_map_reverse = {}; df_user_lookup = pd.DataFrame(); product_list = []; category_to_products_map = {}
except Exception as e:
    print(f"An unexpected error occurred during loading: {e}")
    svd_model = None # Treat unexpected errors as loading failure


# --- Helper Function: Generate Pleasant Random Hex Color ---
def generate_random_color(seed_string):
    """Generates a visually distinct, somewhat pleasant pastel hex color based on a seed string."""
    # Use a hash of the category name for deterministic randomness
    random.seed(hash(seed_string))
    hue = random.random() # Random position on the color wheel
    saturation = random.uniform(0.6, 0.85) # Keep saturation reasonable but vibrant
    lightness = random.uniform(0.75, 0.9) # Keep it light/pastel
    rgb_float = colorsys.hls_to_rgb(hue, lightness, saturation)
    rgb_int = [int(x * 255) for x in rgb_float]
    hex_color = "#{:02x}{:02x}{:02x}".format(rgb_int[0], rgb_int[1], rgb_int[2])
    return hex_color

# --- Helper Function: Calculate Text Contrast Class ---
def get_text_class_for_bg(hex_color):
    """Determines if text should be dark or light based on background hex color."""
    try:
        hex_color = hex_color.lstrip('#')
        if len(hex_color) != 6: return 'dark-text' # Default for invalid hex
        r = int(hex_color[0:2], 16)
        g = int(hex_color[2:4], 16)
        b = int(hex_color[4:6], 16)
        # Calculate perceived brightness using a standard formula (adjust threshold if needed)
        brightness = math.sqrt(0.241 * (r/255)**2 + 0.691 * (g/255)**2 + 0.068 * (b/255)**2) # W3C perceived brightness
        # print(f"DEBUG: Color {hex_color} Brightness: {brightness}") # Uncomment for debugging
        return 'dark-text' if brightness > 0.6 else 'light-text' # Threshold may need tuning
    except ValueError:
        return 'dark-text' # Default if hex conversion fails

# --- Helper Function: Get Real Product Sample with Placeholder ---
def get_real_product_sample_with_emoji(category_name, cat_prod_map):
    """
    Gets a random real product name for the category and a relevant emoji.
    """
    product_names = cat_prod_map.get(category_name)
    real_name = f"Sample {category_name}" # Default name
    if product_names:
        real_name = random.choice(product_names)

    # Get emoji from map or use default
    selected_emoji = CATEGORY_EMOJI_MAP.get(category_name, DEFAULT_EMOJI)

    return {"name": real_name, "emoji": selected_emoji} # Return emoji instead of img


# --- Helper Function: Find Proxy User ---
def find_proxy_user(target_income, target_children, lookup_df, user_map):
    """Finds a random user ID from training data matching demographics."""
    if lookup_df is None or lookup_df.empty or not {'machine_id', 'household_income', 'children'}.issubset(lookup_df.columns):
         return None, "User lookup data missing or invalid."
    if not user_map:
        return None, "User map (model training data) is empty."

    try:
        target_income = int(target_income)
        target_children = int(target_children)
    except (ValueError, TypeError):
        return None, "Invalid demographic input type (expected integer codes)."

    available_model_users = set(user_map.keys()) # Use set for efficient lookup

    # Filter lookup dataframe for users present in the model
    filtered_users = lookup_df[
        (lookup_df['household_income'] == target_income) &
        (lookup_df['children'] == target_children) &
        (lookup_df['machine_id'].isin(available_model_users))
    ]

    if filtered_users.empty:
        print(f"Warn: No exact demo match for Income={target_income}, Children={target_children}. Trying income.")
        filtered_users = lookup_df[(lookup_df['household_income'] == target_income) & (lookup_df['machine_id'].isin(available_model_users))]
        if filtered_users.empty:
             print(f"Warn: No income match. Trying children.")
             filtered_users = lookup_df[(lookup_df['children'] == target_children) & (lookup_df['machine_id'].isin(available_model_users))]
             if filtered_users.empty:
                  print(f"Warn: No demo match found. Using random user.")
                  if not available_model_users: return None, "No users available in model data."
                  proxy_user_id = random.choice(list(available_model_users)); print(f"Selected Random Proxy: {proxy_user_id}"); return proxy_user_id, None

    proxy_user_id = random.choice(filtered_users['machine_id'].tolist())
    print(f"Selected Proxy: {proxy_user_id} based on demo match.")
    return proxy_user_id, None


# --- Recommendation Function ---
def recommend_bundle_approach2_webapp(
    user_id, seed_product, model, cooc_matrix,
    user_map, item_map, item_map_reverse,
    top_n_candidates=50,
    w_recs=0.5, w_cooc_pair=0.3, w_cooc_seed=0.2, # Default weights favoring personalization
    filter_categories=None
    ):
    """Recommends a 2-product bundle using SVD + Co-occurrence Heuristics."""
    if not model: return [], "Model not loaded."
    if filter_categories is None: filter_categories = []

    if user_id not in user_map: return [], f"User ID '{user_id}' not found."
    if seed_product not in item_map: return [], f"Seed product '{seed_product}' not found."

    inner_user_id = user_map[user_id]; inner_seed_id = item_map[seed_product]
    print(f"Reco: U={user_id}({inner_user_id}), S='{seed_product}'({inner_seed_id}), Filter={filter_categories}, W={w_recs},{w_cooc_pair},{w_cooc_seed}")

    all_item_inner_ids = list(item_map_reverse.keys()); predictions = []
    for inner_item_id in all_item_inner_ids:
        raw_iid = item_map_reverse.get(inner_item_id)
        if inner_item_id == inner_seed_id or (raw_iid and raw_iid in filter_categories): continue
        try:
            raw_uid = user_id
            if raw_iid: pred = model.predict(uid=str(raw_uid), iid=str(raw_iid)); predictions.append((inner_item_id, pred.est))
        except Exception as e: print(f"Warn: Predict err U'{raw_uid}', I'{raw_iid}': {e}")

    predictions.sort(key=lambda x: x[1], reverse=True); top_n_items = predictions[:top_n_candidates]
    if len(top_n_items) < 2: return [], "Not enough eligible recommendations."
    print(f"Generated {len(top_n_items)} eligible candidates.")

    candidate_pairs = list(combinations(top_n_items, 2)); scored_pairs = []
    print(f"Scoring {len(candidate_pairs)} candidate pairs...")
    for (item_i_info, item_j_info) in candidate_pairs:
        inner_item_i_id, score_i = item_i_info; inner_item_j_id, score_j = item_j_info
        item_i_name = item_map_reverse.get(inner_item_i_id); item_j_name = item_map_reverse.get(inner_item_j_id)
        if not item_i_name or not item_j_name: continue
        cooc_ij = cooc_matrix.get(item_i_name, {}).get(item_j_name, 0)
        cooc_seed_i = cooc_matrix.get(seed_product, {}).get(item_i_name, 0)
        cooc_seed_j = cooc_matrix.get(seed_product, {}).get(item_j_name, 0)
        final_score = (w_recs * (score_i + score_j) / 2 + w_cooc_pair * cooc_ij + w_cooc_seed * (cooc_seed_i + cooc_seed_j) / 2)
        scored_pairs.append(((item_i_name, item_j_name), final_score))

    if not scored_pairs: return [], "No valid pairs scored."
    scored_pairs.sort(key=lambda x: random.random())
    print(f"Top 5 pairs: {[(pair[0], f'{pair[1]:.4f}') for pair in scored_pairs[:5]]}")
    best_pair = list(scored_pairs[0][0]); 
    return best_pair, None


# --- Flask Routes ---
@app.route('/', methods=['GET', 'POST'])
def index():
    global svd_model, product_list
    if not svd_model:
         flash("CRITICAL ERROR: Recommendation model failed to load. Check logs.", "error")
         return render_template('index.html', products=[], product_details={}, demographics={}, income_levels={}, children_options={}, error=True)

    if request.method == 'POST':
        session['demographics'] = {'income': request.form.get('income'), 'children': request.form.get('children')}
        session.pop('enriched_bundle', None); session.pop('last_viewed', None); session.pop('proxy_user_id', None)
        flash("Demographics saved!", "success"); return redirect(url_for('index'))

    # GET request logic
    demographics = session.get('demographics', {})
    enriched_bundle = session.get('enriched_bundle')
    last_viewed = session.get('last_viewed')
    proxy_user_id = session.get('proxy_user_id')

    income_levels = {"11":"<$25k","12":"$25-40k","13":"$40-60k","14":"$60-75k","15":"$75-100k","16":"$100-150k","17":"$150-200k","18":"$200k+","99":"Unknown"}
    children_options = {"0": "No", "1": "Yes", "99": "Unknown"}
    safe_product_list = sorted(product_list or [])

    # Calculate colors and text classes for the product grid
    product_details = {}
    for prod in safe_product_list:
        bg_color = generate_random_color(prod)
        text_class = get_text_class_for_bg(bg_color)
        product_details[prod] = {'bgcolor': bg_color, 'text_class': text_class}

    return render_template('index.html',
                           products=safe_product_list,
                           product_details=product_details, # Pass combined details
                           demographics=demographics,
                           income_levels=income_levels,
                           children_options=children_options,
                           enriched_bundle=enriched_bundle,
                           last_viewed=last_viewed,
                           proxy_user_id=proxy_user_id,
                           error=False)


@app.route('/view/<path:product_name>')
@app.route('/view/<path:product_name>')
def view_product(product_name):
    global svd_model, df_user_lookup, user_map, category_to_products_map # Need map

    # Keep initial checks and proxy user finding
    if not svd_model: flash("Error: Reco model not loaded.", "error"); return redirect(url_for('index'))
    if 'demographics' not in session or not session['demographics'].get('income'): flash("Set demographics first.", "warning"); return redirect(url_for('index'))
    target_income = session['demographics'].get('income'); target_children = session['demographics'].get('children')
    if df_user_lookup.empty or not user_map: flash("Error: User lookup data missing.", "error"); return redirect(url_for('index'))
    proxy_user_id, error_msg = find_proxy_user(target_income, target_children, df_user_lookup, user_map)
    if error_msg or not proxy_user_id: flash(f"Error finding proxy user: {error_msg or 'Not found.'}", "error"); session['proxy_user_id'] = None; return redirect(url_for('index'))
    session['proxy_user_id'] = proxy_user_id

    # Keep filter list and recommendation call
    categories_to_filter = ["Beauty", "Home Improvement", "Clothing"] # Adjust
    print(f"Requesting bundle for User {proxy_user_id}, Seed: {product_name}")
    recommended_categories, error_msg = recommend_bundle_approach2_webapp(
        user_id=proxy_user_id, seed_product=product_name, model=svd_model,
        cooc_matrix=cooc_matrix, user_map=user_map, item_map=item_map,
        item_map_reverse=item_map_reverse, filter_categories=categories_to_filter
    )

    session['last_viewed'] = product_name
    session['enriched_bundle'] = None

    if error_msg:
        flash(f"Recommendation Info: {error_msg}", "warning")
    elif recommended_categories:
        # --- Enrich bundle using the NEW EMOJI function ---
        bundle_with_samples = []
        print("Enriching bundle with product names and EMOJIS...")
        for category in recommended_categories:
            # Use the function that gets real name + emoji
            sample_info = get_real_product_sample_with_emoji(category, category_to_products_map)
            bundle_with_samples.append({
                'category_name': category,
                'samples': [sample_info] # Keep as list for template structure
            })
        session['enriched_bundle'] = bundle_with_samples
        # ----------------------------------------------------
        flash(f"Bundle suggested based on viewing '{product_name}'!", "info")
    else:
        session['enriched_bundle'] = []
        flash(f"Could not find suitable bundle for '{product_name}'.", "info")

    return redirect(url_for('index'))



@app.route('/clear')
def clear_session():
    session.pop('demographics', None); session.pop('enriched_bundle', None)
    session.pop('last_viewed', None); session.pop('proxy_user_id', None)
    flash("Session cleared.", "info"); return redirect(url_for('index'))


if __name__ == '__main__':
    # Ensure required libraries are installed: pip install Flask pandas surprise scikit-learn joblib colorsys
    app.run(debug=True, host='0.0.0.0', port=5000) # host='0.0.0.0' makes it accessible on local network