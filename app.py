# app.py
from flask import Flask, render_template, request, redirect, url_for, session, flash
import pandas as pd
import joblib
import random
from collections import Counter, defaultdict
from itertools import combinations
import urllib.parse # For encoding text in placeholder URL

app = Flask(__name__)
app.secret_key = 'your_very_secret_key_replace_me' # Change this for production!

# --- Load Pre-trained Models and Data ---
# Attempt to load all necessary files generated by train_and_save.py
try:
    print("Loading pre-trained models and data...")
    svd_model = joblib.load('svd_model.joblib')
    cooc_matrix = joblib.load('cooccurrence_matrix.joblib')
    user_map = joblib.load('user_map.joblib') # raw_user_id -> inner_user_id
    item_map = joblib.load('item_map.joblib') # raw_item_id -> inner_item_id
    item_map_reverse = joblib.load('item_map_reverse.joblib') # inner_item_id -> raw_item_id
    df_user_lookup = joblib.load('user_lookup_data.joblib') # Contains machine_id, household_income, children
    product_list = joblib.load('product_list.joblib') # List of product category names
    category_to_products_map = joblib.load('category_to_products_map.joblib') # Map: category -> [prod_name]
    print("Models and data loaded successfully.")
    # Basic check if maps are loaded correctly
    if not user_map or not item_map:
        print("Warning: User map or item map is empty after loading.")
        svd_model = None # Mark loading as failed if essential maps are empty
except FileNotFoundError as e:
    print(f"Error loading files: {e}")
    print("FATAL: Ensure 'train_and_save.py' was run successfully first!")
    # Set variables to indicate failure to prevent app errors
    svd_model = None
    cooc_matrix = {}
    user_map = {}
    item_map = {}
    item_map_reverse = {}
    df_user_lookup = pd.DataFrame() # Empty dataframe
    product_list = []
    category_to_products_map = {}
except Exception as e:
    print(f"An unexpected error occurred during loading: {e}")
    svd_model = None # Treat unexpected errors as loading failure


# --- Helper Function: Get Real Product Sample ---
def get_real_product_sample(category_name, cat_prod_map):
    """
    Gets a random real product name for the category and a placeholder image.
    Args:
        category_name (str): The name of the category.
        cat_prod_map (dict): The loaded map from category to list of product names.
    Returns:
        dict: {'name': real_product_name, 'img': placeholder_image_url}
    """
    product_names = cat_prod_map.get(category_name)
    real_name = f"Generic {category_name}" # Default name

    if product_names:
        real_name = random.choice(product_names) # Pick a random real name

    # Create a placeholder image URL (encoding the name for the text part)
    placeholder_text = urllib.parse.quote_plus(real_name[:20]) # Limit text length
    placeholder_img = f"https://placehold.co/150x150/E8E8E8/31343C?text={placeholder_text}"

    return {"name": real_name, "img": placeholder_img}


# --- Helper Function: Find Proxy User ---
def find_proxy_user(target_income, target_children, lookup_df, user_map):
    """Finds a random user ID from training data matching demographics."""
    if lookup_df is None or lookup_df.empty or not {'machine_id', 'household_income', 'children'}.issubset(lookup_df.columns):
         return None, "User lookup data is missing or invalid."
    if not user_map:
        return None, "User map (model training data) is empty."

    try:
        target_income = int(target_income)
        target_children = int(target_children)
    except (ValueError, TypeError):
        return None, "Invalid demographic input type (expected integer codes)."

    available_model_users = set(user_map.keys()) # Use set for efficient lookup

    # Filter lookup dataframe for users present in the model
    filtered_users = lookup_df[
        (lookup_df['household_income'] == target_income) &
        (lookup_df['children'] == target_children) &
        (lookup_df['machine_id'].isin(available_model_users)) # Crucial: Ensure user exists in model data
    ]

    if filtered_users.empty:
        # Fallback 1: Try matching only income
        print(f"Warning: No exact demo match for Income={target_income}, Children={target_children}. Trying income match only.")
        filtered_users = lookup_df[
            (lookup_df['household_income'] == target_income) &
            (lookup_df['machine_id'].isin(available_model_users))
        ]
        if filtered_users.empty:
             # Fallback 2: Try matching only children
             print(f"Warning: No match for Income={target_income} either. Trying children match only.")
             filtered_users = lookup_df[
                 (lookup_df['children'] == target_children) &
                 (lookup_df['machine_id'].isin(available_model_users))
             ]
             if filtered_users.empty:
                  # Fallback 3: Use any random user from the model
                  print(f"Warning: No demo match found. Using random user from model data.")
                  if not available_model_users: return None, "No users available in the model data."
                  proxy_user_id = random.choice(list(available_model_users))
                  print(f"Selected Random Proxy User ID: {proxy_user_id}")
                  return proxy_user_id, None # Return the random proxy

    # If any filtering stage found matches:
    proxy_user_id = random.choice(filtered_users['machine_id'].tolist())
    print(f"Selected Proxy User ID: {proxy_user_id} based on demo match (exact or fallback).")
    return proxy_user_id, None


# --- Recommendation Function ---
def recommend_bundle_approach2_webapp(
    user_id, seed_product, model, cooc_matrix,
    user_map, item_map, item_map_reverse,
    top_n_candidates=50,
    w_recs=0.5,       # Default weight for personalization (INCREASED)
    w_cooc_pair=0.3,  # Default weight for pair co-occurrence (DECREASED)
    w_cooc_seed=0.2,  # Default weight for seed co-occurrence (DECREASED)
    filter_categories=None # List of categories to exclude
    ):
    """
    Recommends a 2-product bundle using SVD + Co-occurrence Heuristics,
    with filtering and adjustable weights.
    """
    if not model: return [], "Model not loaded."
    if filter_categories is None: filter_categories = []

    # --- Input Validation ---
    if user_id not in user_map: return [], f"User ID '{user_id}' not found in training data."
    # Check item map using the actual product name string
    if seed_product not in item_map:
        # Provide helpful feedback if seed product isn't recognized
        print(f"Error: Seed product '{seed_product}' not found in item map.")
        # Optionally list some valid items if the map isn't too large
        # print("Available items include:", list(item_map.keys())[:20])
        return [], f"Seed product '{seed_product}' not found in training data."

    inner_user_id = user_map[user_id]
    inner_seed_id = item_map[seed_product]
    print(f"Reco engine: User={user_id}({inner_user_id}), Seed='{seed_product}'({inner_seed_id})")
    print(f"Filtering out: {filter_categories}")
    print(f"Using Weights: Recs={w_recs}, PairCooc={w_cooc_pair}, SeedCooc={w_cooc_seed}")

    # 1. Generate Top-N Single Item Recommendations
    all_item_inner_ids = list(item_map_reverse.keys())
    predictions = []
    for inner_item_id in all_item_inner_ids:
        raw_iid = item_map_reverse.get(inner_item_id) # Get the string name for filtering

        # --- Filtering Categories BEFORE prediction ---
        if inner_item_id == inner_seed_id or (raw_iid and raw_iid in filter_categories):
            continue # Skip seed product and explicitly filtered categories

        try:
            # Predict requires raw IDs (usually strings) as trained
            raw_uid = user_id # Raw user ID
            if raw_iid:
                 # Ensure IDs are strings for prediction if model expects them
                 pred = model.predict(uid=str(raw_uid), iid=str(raw_iid))
                 predictions.append((inner_item_id, pred.est))
        except Exception as e:
            # Catch potential errors during prediction (e.g., item not in trainset for user)
            print(f"Warning: Error predicting for user '{raw_uid}', item '{raw_iid}' (inner id {inner_item_id}): {e}")

    predictions.sort(key=lambda x: x[1], reverse=True)
    top_n_items = predictions[:top_n_candidates] # Get top N *after* filtering

    if len(top_n_items) < 2: return [], "Not enough eligible recommendations found after filtering."
    print(f"Generated {len(top_n_items)} eligible candidate recommendations.")

    # 2. Generate Candidate Pairs and Score Them
    candidate_pairs = list(combinations(top_n_items, 2))
    scored_pairs = []
    print(f"Scoring {len(candidate_pairs)} candidate pairs...")

    for (item_i_info, item_j_info) in candidate_pairs:
        inner_item_i_id, score_i = item_i_info
        inner_item_j_id, score_j = item_j_info
        item_i_name = item_map_reverse.get(inner_item_i_id)
        item_j_name = item_map_reverse.get(inner_item_j_id)
        if not item_i_name or not item_j_name: continue # Should not happen if maps are correct

        # No need to filter pairs again if we filtered individual items above

        # Get co-occurrence scores safely using .get()
        cooc_ij = cooc_matrix.get(item_i_name, {}).get(item_j_name, 0)
        cooc_seed_i = cooc_matrix.get(seed_product, {}).get(item_i_name, 0)
        cooc_seed_j = cooc_matrix.get(seed_product, {}).get(item_j_name, 0)

        # --- Heuristic Scoring Formula ---
        final_score = (w_recs * (score_i + score_j) / 2 +
                       w_cooc_pair * cooc_ij +
                       w_cooc_seed * (cooc_seed_i + cooc_seed_j) / 2)

        scored_pairs.append(((item_i_name, item_j_name), final_score))

    # 3. Rank Pairs and Return Top One
    if not scored_pairs: return [], "No valid pairs scored."

    scored_pairs.sort(key=lambda x: random.random(), reverse=True)
    print(f"Top 5 scored pairs overall: {[(pair[0], f'{pair[1]:.4f}') for pair in scored_pairs[:5]]}")

    best_pair = list(scored_pairs[0][0])
    return best_pair, None # Return bundle and no error message


# --- Flask Routes ---
@app.route('/', methods=['GET', 'POST'])
def index():
    global svd_model, product_list # Allow modification if reload needed
    if not svd_model:
         flash("CRITICAL ERROR: Recommendation model failed to load. Check server logs and ensure 'train_and_save.py' ran correctly.", "error")
         # Try to gracefully handle by showing the page without dynamic content
         return render_template('index.html', products=[], demographics={}, income_levels={}, children_options={}, enriched_bundle=None, last_viewed=None, proxy_user_id=None, error=True)


    if request.method == 'POST':
        session['demographics'] = {
            'income': request.form.get('income'),
            'children': request.form.get('children')
        }
        session.pop('enriched_bundle', None)
        session.pop('last_viewed', None)
        session.pop('proxy_user_id', None)
        flash("Demographics saved! Please browse products.", "success")
        return redirect(url_for('index'))

    # GET request logic
    demographics = session.get('demographics', {})
    enriched_bundle = session.get('enriched_bundle')
    last_viewed = session.get('last_viewed')
    proxy_user_id = session.get('proxy_user_id')

    income_levels = {
        "11": "Less than $25,000", "12": "$25,000 - $39,999", "13": "$40,000 - $59,999",
        "14": "$60,000 - $74,999", "15": "$75,000 - $99,999", "16": "$100,000 - $149,999",
        "17": "$150,000 - $199,999", "18": "$200,000+", "99": "Unknown"
    }
    children_options = {"0": "No", "1": "Yes", "99": "Unknown"}

    # Use the globally loaded product_list, ensure it's sorted
    safe_product_list = sorted(product_list or [])

    return render_template('index.html',
                           products=safe_product_list,
                           demographics=demographics,
                           income_levels=income_levels,
                           children_options=children_options,
                           enriched_bundle=enriched_bundle,
                           last_viewed=last_viewed,
                           proxy_user_id=proxy_user_id,
                           error=False) # Indicate no critical loading error


@app.route('/view/<path:product_name>')
def view_product(product_name):
    global svd_model, df_user_lookup, user_map # Access global variables

    if not svd_model:
         flash("Error: Recommendation model is not loaded.", "error")
         return redirect(url_for('index'))
    if 'demographics' not in session or not session['demographics'].get('income'):
        flash("Please set your demographics first.", "warning")
        return redirect(url_for('index'))

    # Find proxy user
    target_income = session['demographics'].get('income')
    target_children = session['demographics'].get('children')

    # Ensure necessary data for proxy finding is available
    if df_user_lookup.empty or not user_map:
         flash("Error: User lookup data or user map is missing.", "error")
         return redirect(url_for('index'))

    proxy_user_id, error_msg = find_proxy_user(target_income, target_children, df_user_lookup, user_map)

    if error_msg or not proxy_user_id:
        flash(f"Error finding representative user: {error_msg or 'Could not find proxy.'}", "error")
        session['proxy_user_id'] = None # Clear invalid proxy
        return redirect(url_for('index'))

    session['proxy_user_id'] = proxy_user_id # Store valid proxy

    # --- Specify categories to filter out ---
    # Make this configurable if needed, e.g., from a settings file
    categories_to_filter = ["Beauty", "Home Improvement", "Clothing"] # Example filter list

    # Generate bundle recommendation
    print(f"Requesting bundle for User {proxy_user_id}, Seed: {product_name}")
    recommended_categories, error_msg = recommend_bundle_approach2_webapp(
        user_id=proxy_user_id,
        seed_product=product_name,
        model=svd_model,
        cooc_matrix=cooc_matrix,
        user_map=user_map,
        item_map=item_map,
        item_map_reverse=item_map_reverse,
        filter_categories=categories_to_filter,
        # You can still override weights/params here for testing:
        # w_recs = 0.6, w_cooc_pair = 0.2, w_cooc_seed = 0.2, top_n_candidates=75
    )

    session['last_viewed'] = product_name
    session['enriched_bundle'] = None # Clear previous bundle

    if error_msg:
        flash(f"Recommendation Info: {error_msg}", "warning") # Downgrade error to warning/info
    elif recommended_categories:
        bundle_with_samples = []
        for category in recommended_categories:
            # Use the function to get a real name + placeholder image
            sample_info = get_real_product_sample(category, category_to_products_map)
            bundle_with_samples.append({
                'category_name': category,
                'samples': [sample_info] # Keep as list for template consistency
            })
        session['enriched_bundle'] = bundle_with_samples
        flash(f"Bundle suggested based on viewing '{product_name}'!", "info")
    else:
        session['enriched_bundle'] = [] # Indicate no bundle found
        flash(f"Could not find a suitable bundle for '{product_name}' (possibly due to filtering or low scores).", "info")

    return redirect(url_for('index'))

@app.route('/clear')
def clear_session():
    # Clear specific session keys related to user state
    session.pop('demographics', None)
    session.pop('enriched_bundle', None)
    session.pop('last_viewed', None)
    session.pop('proxy_user_id', None)
    flash("Session cleared.", "info")
    return redirect(url_for('index'))

if __name__ == '__main__':
    # Set host='0.0.0.0' to make accessible on local network if needed
    app.run(debug=True, host='0.0.0.0', port=5000)